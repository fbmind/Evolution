## 项目简介

本项目是一个实验性的小内核，开发环境为 Linux 32bit，采用 NASM 汇编和 C 语言进行开发，使用 Bochs 进行模拟调试。

项目分为 Boot 和 Kernel 两个部分。Boot 存储在引导扇区，Kernel 占用扇区数存储在第二个扇区，Kernel 存储在从第三个扇区开始的若干扇区。整体流程如下：

开机后，BIOS 加载并执行引导扇区的代码。引导扇区首先加载 GDT 并进入保护模式，GDT 里存放了 3 个平坦模式段，分别为代码段，数据段和栈段。然后设置静态页目录表和页表并开启分页功能，页目录表和页表映射了从 0 开始的 4M 空间，从 3G 开始的 4M 空间和线性地址最后 4M 空间。然后读取硬盘第二个扇区中存储的内核占用扇区总数，根据该参数从硬盘读取内核，内核位于从 0 开始的 4M 空间内。内核为 ELF 文件格式，入口地址为 0xC0000400，该地址位于 3G 以上的地址空间，因此内核中各个段的地址也位于 3G 以上地址空间，解析内核的 ELF 头部，把内核的各个段放在合适的位置，然后跳入内核执行。

因为 boot 使用的 GTD 位于引导扇区内部，我们还需要添加更多的描述符，因此内核需要使用自己的变量 gdt_info 和 gdt 来管理 GDT。内核首先重新加载 GDT，然后初始化 IDT 并加载 IDT，开启异常和中断处理程序。然后内核初始化 8259A 开启时钟中断。然后初始化含有 4 个用户进程的进程表，伪造一个能从内核跳入用户进程 task_a 的栈，并执行跳入，此时 CPU 进入 ring3。 当有时钟中断发生时，中断处理程序计算每个进行运行的时钟滴答数，当运行足够多的时钟滴答数之后，内核选择另外一个用户进程运行。此时 task_a task_b task_c task_d 交替执行，在屏幕上打印出 AABBCCDDAABBCCDD 类似的字符串。

## 一级分页和两级分页的区别，为什么会省空间？

4G 物理内存 -> 10^20 个 4K 页 -> 10^20 个页表项 -> 4M 内存
cpu 记住了该页表的地址，线性地址的前 20 位为页表的下标。从中选出一个页表项，该页表项的前 20 位为物理页的物理地址，线性地址的后 12 位为页内偏移。
进程使用哪些线性地址是不确定的，不能做做任何假设。给出了页表地址后，页表所占用的 4M 物理内存就不能挪作他用。本质原因时页表是线性存储的。

4G 物理内存 -> 10^20 个 4K 页 -> 1 个页目录表，2^10 个页目录项，每个页目录项目可容纳 4M 内存 -> 每个页表 2^10 个页表项，每个页表项容纳 4K 内存 -> 总共可容纳 4G 内存
cpu 记住了页目录表的地址，线性地址的高 10 位为页目录表的下标。从中选出一个页目录项，改页目录项的前 20 位为页表的物理地址。线性地址的中间 10 位为页表的下标，从中选出一个页表项，该页表项的前 20 位为页的物理地址。线性地址的后 12 位为页内偏移。
对于一个线性地址，页目录表的地址是固定的，其占用的 4K 内存不可以挪作他用。但是页表的地址是在页目录里面填写的，用的时候填写即可，不用存储全部的页表。本质原因是页表不需要线性存储。

## 页目录项和页表项中存放的是什么地址？
页目录项和页表项里面存放的地址是物理地址，页部件使用页表做线性地址到物理地址的转换，若里面存的是线性地址，将无法解析。

## 开启分页机制后，如何修改页面也页目录表的内容？
开启分页机制后，代码中的逻辑地址被转换成线性地址。所以代码中访问 GDT，变量的地址全部都是线性地址。访问也表也需要如此。

假设某个线性地址的三部分组成为 A B C
pagedir[A] = pagedir
pagedir[B] = pagedir

A/B/000 - A/B/FFF 此 4K 线性地址空间访问的是页目录
A/0/0 - A/CFF/FF 此 4M 线性地址空间访问页目录和页表，页目录本身也是页表，该页表

A/A/C
A/B/C

A/A/* A/B/* 这 8K 线性空间都指向了页目录表

B/A/C
B/B/C 这 4 个线性地址指向的是同一个物理地址。

B/A/* B/B/* 这 8K 线性空间都指向了页目录表

线性地址空间中 A/*/* B/*/* 的 8M 线性空间都指向了页表。

若 A == B，则线性空间中有 4M 指向了页表，页目录表也是页表，页目录表作为页表时指向了所有页表。
若 A == B == 0CFFh 或 A == B == 0 则可以将页表的放在线性空间的开头或者结尾部分，不至于将页表割裂。

## 最开始时，为了使内核正常运行，如何设置页表的映射，使得线性地址等于物理地址？

## 平坦模式下，分页机制是如何起到保护作用的？

## 平坦模式下，内核挪到高 1G 空间后，其编译时的地址应该也在高地址空间，内核最初加载，分页机制开启之前怎么办？难道要加一个 Loader。

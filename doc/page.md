## 一级分页和两级分页的区别，为什么会省空间？

4G 物理内存 -> 10^20 个 4K 页 -> 10^20 个页表项 -> 4M 内存
cpu 记住了该页表的地址，线性地址的前 20 位为页表的下标。从中选出一个页表项，该页表项的前 20 位为物理页的物理地址，线性地址的后 12 位为页内偏移。
进程使用哪些线性地址是不确定的，不能做做任何假设。给出了页表地址后，页表所占用的 4M 物理内存就不能挪作他用。本质原因时页表是线性存储的。

4G 物理内存 -> 10^20 个 4K 页 -> 1 个页目录表，2^10 个页目录项，每个页目录项目可容纳 4M 内存 -> 每个页表 2^10 个页表项，每个页表项容纳 4K 内存 -> 总共可容纳 4G 内存
cpu 记住了页目录表的地址，线性地址的高 10 位为页目录表的下标。从中选出一个页目录项，改页目录项的前 20 位为页表的物理地址。线性地址的中间 10 位为页表的下标，从中选出一个页表项，该页表项的前 20 位为页的物理地址。线性地址的后 12 位为页内偏移。
对于一个线性地址，页目录表的地址是固定的，其占用的 4K 内存不可以挪作他用。但是页表的地址是在页目录里面填写的，用的时候填写即可，不用存储全部的页表。本质原因是页表不需要线性存储。

## 页目录项和页表项中存放的是什么地址？
页目录项和页表项里面存放的地址是物理地址，页部件使用页表做线性地址到物理地址的转换，若里面存的是线性地址，将无法解析。

## 开启分页机制后，如何修改页面也页目录表的内容？
开启分页机制后，代码中的逻辑地址被转换成线性地址。所以代码中访问 GDT，变量的地址全部都是线性地址。访问也表也需要如此。

页目录表已经存在，其物理地址为 A，开启保护模式后，其线性地址为 A，

A && 0FFC00000h 该偏移所对应的页目录项中的物理地址为页目录表的物理地址 A，指向的页表为页目录表本身。
A && 0003FF000h
A && 000000FFFh

## 最开始时，为了使内核正常运行，如何设置页表的映射，使得线性地址等于物理地址？

## 平坦模式下，分页机制是如何起到保护作用的？

## 平坦模式下，内核挪到高 1G 空间后，其编译时的地址应该也在高地址空间，内核最初加载，分页机制开启之前怎么办？难道要加一个 Loader。
